<!doctype html>
<html lang="en-us">
  <head>
    <title> // 林永晖</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.92.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://therolf07200.github.io/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="CMAKE Website 官网： CMake
官方教学：CMake Tutorial — CMake 3.24.0 Documentation
Previously knowledge 编译器 编译器：是一个根据源代码生成机器码的程序
example:
g&#43;&#43; main.cpp -o a.out objdump -D a.out | less //反汇编 make
正文  为了解决make的以上问题，跨平台的CMake应运而生 只需写一份CMakeLists.txt，就能在调用时生成当前系统所支持的构建系统 CMake可以自动检测源文件和头文件的依赖关系，导出到Makefile文件里 Cmake具有相对比较高级的语法，内置的函数能够处理configure，install等常见需求 CMake可以自动检测当前的编译器，需要添加那些flag。比如OpenMP，只需要在CMakeLists.txt中指明target_link_libraries(a.out OpenMP::OpemMP_CXX)即可   CMakeLists.txt example:
 cmake_minimum_required(VERSION 3.10) # set the project name project(hellocmake LANGUAGES CXX) # add the executable add_executable(a.out main.cpp hello.cpp) command:
cmake -B build cd build make ./a.out library   有时候我们会有很多可执行文件，他们之间用到的某些功能是相同的，我们会把这些公用的功能做成一个库（library），方便大家一起共享
  库中的函数可以被可执行文件调用，也可以被其他库调用"/>

    <meta property="og:title" content="" />
<meta property="og:description" content="CMAKE Website 官网： CMake
官方教学：CMake Tutorial — CMake 3.24.0 Documentation
Previously knowledge 编译器 编译器：是一个根据源代码生成机器码的程序
example:
g&#43;&#43; main.cpp -o a.out objdump -D a.out | less //反汇编 make
正文  为了解决make的以上问题，跨平台的CMake应运而生 只需写一份CMakeLists.txt，就能在调用时生成当前系统所支持的构建系统 CMake可以自动检测源文件和头文件的依赖关系，导出到Makefile文件里 Cmake具有相对比较高级的语法，内置的函数能够处理configure，install等常见需求 CMake可以自动检测当前的编译器，需要添加那些flag。比如OpenMP，只需要在CMakeLists.txt中指明target_link_libraries(a.out OpenMP::OpemMP_CXX)即可   CMakeLists.txt example:
 cmake_minimum_required(VERSION 3.10) # set the project name project(hellocmake LANGUAGES CXX) # add the executable add_executable(a.out main.cpp hello.cpp) command:
cmake -B build cd build make ./a.out library   有时候我们会有很多可执行文件，他们之间用到的某些功能是相同的，我们会把这些公用的功能做成一个库（library），方便大家一起共享
  库中的函数可以被可执行文件调用，也可以被其他库调用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://therolf07200.github.io/post/programming-/cmake-6fca7da7da644b5d8f93853b4c9d6e91/" /><meta property="article:section" content="post" />





  </head>
  <body>
    <header class="app-header">
      <a href="https://therolf07200.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>林永晖</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title"></h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 1, 0001
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="cmake">CMAKE</h1>
<h1 id="website">Website</h1>
<p>官网： <a href="https://cmake.org/">CMake</a></p>
<p>官方教学：<a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutorial — CMake 3.24.0 Documentation</a></p>
<h1 id="previously-knowledge">Previously knowledge</h1>
<h2 id="编译器">编译器</h2>
<p>编译器：是一个根据源代码生成机器码的程序</p>
<p>example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">g++ main.cpp -o a.out

objdump -D a.out | less  //反汇编
</code></pre></div><p><a href="CMAKE%206fca7da7da644b5d8f93853b4c9d6e91/make%20b57214e4cf4549cebe7150d26ccaa063.md">make</a></p>
<h1 id="正文">正文</h1>
<ul>
<li>为了解决make的以上问题，跨平台的CMake应运而生</li>
<li>只需写一份CMakeLists.txt，就能在调用时生成当前系统所支持的构建系统</li>
<li>CMake可以自动检测源文件和头文件的依赖关系，导出到Makefile文件里</li>
<li>Cmake具有相对比较高级的语法，内置的函数能够处理configure，install等常见需求</li>
<li>CMake可以自动检测当前的编译器，需要添加那些flag。比如OpenMP，只需要在CMakeLists.txt中指明target_link_libraries(a.out OpenMP::OpemMP_CXX)即可</li>
</ul>
<blockquote>
<p>CMakeLists.txt example:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cmake_minimum_required<span style="color:#f92672">(</span>VERSION 3.10<span style="color:#f92672">)</span>

<span style="color:#75715e"># set the project name</span>
project<span style="color:#f92672">(</span>hellocmake LANGUAGES CXX<span style="color:#f92672">)</span>

<span style="color:#75715e"># add the executable</span>
add_executable<span style="color:#f92672">(</span>a.out main.cpp hello.cpp<span style="color:#f92672">)</span>
</code></pre></div><p>command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cmake -B build
cd build
make
./a.out
</code></pre></div><h2 id="library">library</h2>
<ul>
<li>
<p>有时候我们会有很多可执行文件，他们之间用到的某些功能是相同的，我们会把这些公用的功能做成一个库（library），方便大家一起共享</p>
</li>
<li>
<p>库中的函数可以被可执行文件调用，也可以被其他库调用</p>
</li>
<li>
<p>库文件可分为：<strong>静态库文件</strong>和<strong>动态库文件</strong></p>
</li>
<li>
<p>其中静态库文件相当于直接把代码插入到从生成的可执行文件中，会导致文件体积变大，但是只需要一个文件即可运行</p>
</li>
<li>
<p>而动态库则只在生成的可执行文件中生成“插桩”函数，当可执行文件被加载时会读取指定目录中的dll文件没加载到内存的空闲位置，并替换相应的“插桩”指向的地址为加载后的地址，这个过程成为<strong>重定向</strong>。这样以后函数被调用就会跳转到动态加载的地址去。</p>
</li>
<li>
<p>Windows：可执行文件同目录，其次是环境变量%PATH%</p>
</li>
<li>
<p>Linux：ELF格式可执行文件的RPATH，其次是/usr/lib</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ldd a.out   //查看连接的动态库
</code></pre></div></li>
</ul>
<h2 id="cmake中的静态库与动态库">CMake中的静态库与动态库</h2>
<ul>
<li>CMake除了 add_executable可以生成<strong>可执行文件</strong>外，还可以通过add_library生成<strong>库文件</strong></li>
<li>add_library的语法与add_executable大致相同，除了需要指定是动态库还是静态库</li>
<li>add_library（test STATIC source1.cpp source2.cpp） #生成静态库libtest.a</li>
<li>add_library（test SHEARED source1.cpp source2.cpp）#生成动态库libtest.so</li>
<li>创建库以后，要在某个<strong>可执行文件</strong>中使用该库，只需要：</li>
<li>target_link_libraries(a,out PUBLIC test) #为a.out链接刚才制作的库libtest.a</li>
</ul>
<h2 id="cmake中的子模块">CMake中的子模块</h2>
<ul>
<li>在复杂的工程中，通常需要子模块，比如：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">hellolib
		CMakeLists.txt
		hello.cpp
		hello.h
CMakeLists.txt
CMakeLists.txt
</code></pre></div><ul>
<li>这里把hellolib库的东西移到hellolib文件夹下，里面的CMakeLists.txt定义了hellolib生成的规则</li>
<li>要在根目录使用方他，可以用CMake的add_subdirectory 添加子目录，子目录也包含一个CMakeLists.txt，其中定义的库在add_subdirectory之后就可以在外面使用</li>
<li>子目录的CMakeLists,txt 里路径名（比如hello.cpp）都是相对路径，这也是很方便的一点</li>
</ul>
<p><img src="CMAKE%206fca7da7da644b5d8f93853b4c9d6e91/1660109251724.png" alt="1660109251724.png"></p>
<h2 id="子模块的头文件如何处理">子模块的头文件如何处理</h2>
<ul>
<li>
<p>因为hello.h被移到了hellolib中，因此main.cpp里也要改成  #include “./hellolib/hello.h”</p>
</li>
<li>
<p>如果要避免修改代码，我们可以通过修改target_include_directories指定</p>
</li>
<li>
<p>a.out的头文件搜索目录：（其中第一个hellolib是库名，第二个是目录）</p>
</li>
<li>
<p>这样甚至可以用&lt;hello.h&gt;来引用这个头文件了，因为通过target_include_directories指定的路径会被视为与系统路径等价</p>
</li>
<li>
<p>可以将target_include_directories（hellolib PUBLIC .）写在子模块中，这里使用 . 表示当前路径，因为子目录里的路径是相对路径，类似的，还有 .. 表示上层目录</p>
</li>
<li>
<p>此外，如果不希望让引用hellolib的可执行文件自动添加这个路径，可以把PUBLIC改成PRIVATE即可：决定一个属性要不要再被link的时候传播</p>
</li>
</ul>
<p><img src="CMAKE%206fca7da7da644b5d8f93853b4c9d6e91/Untitled.png" alt="Untitled"></p>
<h2 id="第三方库---作为纯文件引入">第三方库 - 作为纯文件引入</h2>
<ul>
<li>有时候我们不满足于C++标准库功能，难免会用到一些第三方库</li>
<li>最友好的一类库莫过于纯头文件了，这里是一些好用的header-only库</li>
</ul>
<p><img src="CMAKE%206fca7da7da644b5d8f93853b4c9d6e91/Untitled%201.png" alt="Untitled"></p>
<h2 id="第三方库---作为子模块引入">第三方库 - 作为子模块引入</h2>
<ul>
<li>第二个友好的方式则是作为CMake的子模块引入</li>
<li>方法就是把那个项目（以fmt为例）的源码放到你的工程根目录下</li>
<li>这些库能够很好地支持作为子模块引入</li>
</ul>
<p><img src="CMAKE%206fca7da7da644b5d8f93853b4c9d6e91/Untitled%202.png" alt="Untitled"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cmake_minimum_required<span style="color:#f92672">(</span>VERSION 3.12<span style="color:#f92672">)</span>
project<span style="color:#f92672">(</span>hellocmake LANGUAGES CXX<span style="color:#f92672">)</span>

add_subdirectories<span style="color:#f92672">(</span>fmt<span style="color:#f92672">)</span>

add_executable<span style="color:#f92672">(</span>a.out main.cpp<span style="color:#f92672">)</span>
target_link_libraries<span style="color:#f92672">(</span>a.out PUBLIC fmt<span style="color:#f92672">)</span>
</code></pre></div><h2 id="第三方库---引用系统中预安装的第三方库">第三方库 - 引用系统中预安装的第三方库</h2>
<ul>
<li>可以通过find_package命令查找系统中的库</li>
<li>find_package(fmt REQUIRED)</li>
<li>traget_link_libraries(myexec PUBLIC fmt::fmt)</li>
<li>为什么事fmt::fmt而不是简单地fmt呢？</li>
<li>现代CMake认为一个<strong>包</strong>（Package）可以提供多个<strong>库</strong>，又称<strong>组件</strong>（component），比如TBB这个包，就包含了tbb, tbbmalloc, tbbmalloc_proxy这三个组件</li>
<li>因此为避免冲突，每个包都享有一个独立的名字空间，以 :: 分割</li>
<li>你可以指定要用那个组件
<ul>
<li>find_package(TBB <strong>REQUIRED COMPONENTS</strong> tbb tbbmalloc <strong>REQUIRED</strong>)</li>
<li>target_link_libraries(myexec <strong>PUBLIC</strong> TBB::tbb TBB::tbbmalloc)</li>
</ul>
</li>
</ul>
<p><img src="CMAKE%206fca7da7da644b5d8f93853b4c9d6e91/Untitled%203.png" alt="Untitled"></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
